function SpentCasingPhysics.update()
local dt = SpentCasingPhysics.GT():getTimeDelta()
local scale = dt * 60
local i = 1

while i <= #SpentCasingPhysics.activeCasings do
local casing = SpentCasingPhysics.activeCasings[i]
local removed = false

if not casing or not casing.square or not casing.active then
table.remove(SpentCasingPhysics.activeCasings, i)
removed = true
else
local prevZ = casing.z or 0
local oldEdgeX = casing.x
local oldEdgeY = casing.y
casing.velocityZ = casing.velocityZ -
(SpentCasingPhysics.GRAVITY * SpentCasingPhysics.GRAVITY_SCALE * scale)

casing.x = casing.x + (casing.velocityX * SpentCasingPhysics.XY_STEP * scale)
casing.y = casing.y + (casing.velocityY * SpentCasingPhysics.XY_STEP * scale)
casing.z = casing.z + (casing.velocityZ * SpentCasingPhysics.Z_STEP * scale)

casing.z = math.max(0, casing.z)

local worldX = casing.square:getX() + casing.x
local worldY = casing.square:getY() + casing.y
local worldZ = casing.square:getZ()

local dragXY = math.pow(SpentCasingPhysics.DRAG_XY, scale)
local dragZ = math.pow(SpentCasingPhysics.DRAG_Z, scale)
casing.velocityX = casing.velocityX * dragXY
casing.velocityY = casing.velocityY * dragXY
casing.velocityZ = casing.velocityZ * dragZ

local localX = worldX - casing.square:getX()
local localY = worldY - casing.square:getY()
local edgeX = localX
local edgeY = localY

local EDGE_TOL = 0.15

local sx = casing.square:getX()
local sy = casing.square:getY()
local sz = casing.square:getZ()

local blockX = false
local blockY = false

if casing.velocityX > 0 and oldEdgeX < (1.0 - EDGE_TOL) and edgeX >= (1.0 - EDGE_TOL) then
local neighbor = getCell():getGridSquare(sx + 1, sy, sz)
if neighbor and SpentCasingPhysics.isBlockedBetweenSquares(casing.square, neighbor, SpentCasingPhysics.IsoDirections.E, casing.z) then
blockX = true
end
elseif casing.velocityX < 0 and oldEdgeX > EDGE_TOL and edgeX <= EDGE_TOL then
local neighbor = getCell():getGridSquare(sx - 1, sy, sz)
if neighbor and SpentCasingPhysics.isBlockedBetweenSquares(casing.square, neighbor, SpentCasingPhysics.IsoDirections.W, casing.z) then
blockX = true
end
end

if casing.velocityY > 0 and oldEdgeY < (1.0 - EDGE_TOL) and edgeY >= (1.0 - EDGE_TOL) then
local neighbor = getCell():getGridSquare(sx, sy + 1, sz)
if neighbor and SpentCasingPhysics.isBlockedBetweenSquares(casing.square, neighbor, SpentCasingPhysics.IsoDirections.S, casing.z) then
blockY = true
end
elseif casing.velocityY < 0 and oldEdgeY > EDGE_TOL and edgeY <= EDGE_TOL then
local neighbor = getCell():getGridSquare(sx, sy - 1, sz)
if neighbor and SpentCasingPhysics.isBlockedBetweenSquares(casing.square, neighbor, SpentCasingPhysics.IsoDirections.N, casing.z) then
blockY = true
end
end

if blockX then
casing.velocityX = -casing.velocityX * SpentCasingPhysics.BOUNCE_RESTITUTION
casing.x = casing.x + (casing.velocityX * SpentCasingPhysics.BOUNCE_POSITION_CORRECT)
if math.abs(casing.velocityX) < SpentCasingPhysics.BOUNCE_MIN_VELOCITY then
casing.velocityX = 0
end
end

if blockY then
casing.velocityY = -casing.velocityY * SpentCasingPhysics.BOUNCE_RESTITUTION
casing.y = casing.y + (casing.velocityY * SpentCasingPhysics.BOUNCE_POSITION_CORRECT)
if math.abs(casing.velocityY) < SpentCasingPhysics.BOUNCE_MIN_VELOCITY then
casing.velocityY = 0
end
end

if blockX or blockY then
worldX = casing.square:getX() + casing.x
worldY = casing.square:getY() + casing.y
end

local targetTileX = math.floor(worldX)
local targetTileY = math.floor(worldY)

local MIN_Z = -1
local checkZ = worldZ
local targetSquare = nil
local drops = 0

while checkZ >= MIN_Z do
local sq = getCell():getGridSquare(targetTileX, targetTileY, checkZ)

if not sq then
break
end

if sq:getFloor() then
targetSquare = sq
break
end

checkZ = checkZ - 1
drops = drops + 1
end

if not targetSquare then
targetSquare = casing.square
else
if drops > 0 then
casing.z = casing.z + drops
end
end

local localX2 = worldX - targetSquare:getX()
local localY2 = worldY - targetSquare:getY()

localX2 = PZMath.clamp_01(localX2)
localY2 = PZMath.clamp_01(localY2)

if casing.currentWorldItem then
local wobj = casing.currentWorldItem:getWorldItem()
if wobj then
if isServer() then
casing.square:transmitRemoveItemFromSquare(wobj)
end
casing.square:removeWorldObject(wobj)
end
casing.currentWorldItem = nil
end

local falling = (casing.velocityZ <= 0)

local tileTopZ = nil
if not casing.hasHitFloor and falling then
tileTopZ = SpentCasingPhysics.getTileTopZ(targetSquare)
end

local surfaceZ = 0.0

if tileTopZ then
if prevZ >= tileTopZ and casing.z <= tileTopZ then
surfaceZ = tileTopZ
end
end

if casing.z > surfaceZ then
casing.currentWorldItem = targetSquare:AddWorldInventoryItem(
casing.casingType,
localX2,
localY2,
casing.z
)
else
local floor = targetSquare and targetSquare:getFloor() or nil

if surfaceZ == 0.0 then
casing.hasHitFloor = true
end

if surfaceZ == 0.0 and SpentCasingPhysics.isWaterFloor(floor) then
casing.active = false
table.remove(SpentCasingPhysics.activeCasings, i)
removed = true
SpentCasingPhysics.playCasingImpactSound(casing, targetSquare)
else
local speedXY = math.sqrt(
casing.velocityX * casing.velocityX +
casing.velocityY * casing.velocityY
)

local canBounceHere =
casing.floorBounces and casing.floorBounces > 0 and
speedXY > SpentCasingPhysics.SETTLE_THRESHOLD
if surfaceZ == 0.0 and floor and SpentCasingPhysics.isSoftFloor(floor) then
canBounceHere = false
end

if canBounceHere then
casing.floorBounces     = casing.floorBounces - 1
casing.z                = surfaceZ + 0.05
casing.velocityZ        = math.abs(casing.velocityZ) * SpentCasingPhysics.BOUNCE_RESTITUTION
casing.velocityX        = casing.velocityX * 0.5
casing.velocityY        = casing.velocityY * 0.5

casing.currentWorldItem = targetSquare:AddWorldInventoryItem(
casing.casingType,
localX2,
localY2,
casing.z
)
SpentCasingPhysics.playCasingImpactSound(casing, targetSquare)
else
targetSquare:AddWorldInventoryItem(
casing.casingType,
localX2,
localY2,
surfaceZ
)
SpentCasingPhysics.playCasingImpactSound(casing, targetSquare)
casing.active = false
table.remove(SpentCasingPhysics.activeCasings, i)
removed = true
end
end
end

if not removed then
if targetSquare ~= casing.square then
casing.square = targetSquare
end

casing.x = PZMath.clamp_01(localX2)
casing.y = PZMath.clamp_01(localY2)
end
end

if not removed then
i = i + 1
end
end
end

------------------ the other update with the bullshit for server


function SpentCasingPhysics.update()
-- local dt = SpentCasingPhysics.GT():getTimeDelta()
-- local scale = dt * 60

local dt = SpentCasingPhysics.GT():getTimeDelta()
if dt > 0.2 then dt = 0.2 end

local BASELINE_TPS = 60
local SERVER_SPEED_MULT = isServer() and SandboxVars.HB.serverMult or 1.0
local TARGET_SUBSCALE = 1.0
local totalScale = dt * BASELINE_TPS * SERVER_SPEED_MULT
local steps = math.max(1, math.ceil(totalScale / TARGET_SUBSCALE))

local MAX_SUBSTEPS = SandboxVars.HB.MaxSubSteps or 8
if steps > MAX_SUBSTEPS then steps = MAX_SUBSTEPS end
local subScale = totalScale / steps

for _ = 1, steps do
local scale = subScale
local i = 1

while i <= #SpentCasingPhysics.activeCasings do
local casing = SpentCasingPhysics.activeCasings[i]
local removed = false

if not casing or not casing.square or not casing.active then
table.remove(SpentCasingPhysics.activeCasings, i)
removed = true
else
local prevZ = casing.z or 0
local oldEdgeX = casing.x
local oldEdgeY = casing.y
casing.velocityZ = casing.velocityZ -
(SpentCasingPhysics.GRAVITY * SpentCasingPhysics.GRAVITY_SCALE * scale)

casing.x = casing.x + (casing.velocityX * SpentCasingPhysics.XY_STEP * scale)
casing.y = casing.y + (casing.velocityY * SpentCasingPhysics.XY_STEP * scale)
casing.z = casing.z + (casing.velocityZ * SpentCasingPhysics.Z_STEP * scale)

casing.z = math.max(0, casing.z)

local worldX = casing.square:getX() + casing.x
local worldY = casing.square:getY() + casing.y
local worldZ = casing.square:getZ()

local dragXY = math.pow(SpentCasingPhysics.DRAG_XY, scale)
local dragZ = math.pow(SpentCasingPhysics.DRAG_Z, scale)
casing.velocityX = casing.velocityX * dragXY
casing.velocityY = casing.velocityY * dragXY
casing.velocityZ = casing.velocityZ * dragZ

local localX = worldX - casing.square:getX()
local localY = worldY - casing.square:getY()
local edgeX = localX
local edgeY = localY

local EDGE_TOL = 0.15

local sx = casing.square:getX()
local sy = casing.square:getY()
local sz = casing.square:getZ()

local blockX = false
local blockY = false

if casing.velocityX > 0 and oldEdgeX < (1.0 - EDGE_TOL) and edgeX >= (1.0 - EDGE_TOL) then
local neighbor = getCell():getGridSquare(sx + 1, sy, sz)
if neighbor and SpentCasingPhysics.isBlockedBetweenSquares(casing.square, neighbor, SpentCasingPhysics.IsoDirections.E, casing.z) then
blockX = true
end
elseif casing.velocityX < 0 and oldEdgeX > EDGE_TOL and edgeX <= EDGE_TOL then
local neighbor = getCell():getGridSquare(sx - 1, sy, sz)
if neighbor and SpentCasingPhysics.isBlockedBetweenSquares(casing.square, neighbor, SpentCasingPhysics.IsoDirections.W, casing.z) then
blockX = true
end
end

if casing.velocityY > 0 and oldEdgeY < (1.0 - EDGE_TOL) and edgeY >= (1.0 - EDGE_TOL) then
local neighbor = getCell():getGridSquare(sx, sy + 1, sz)
if neighbor and SpentCasingPhysics.isBlockedBetweenSquares(casing.square, neighbor, SpentCasingPhysics.IsoDirections.S, casing.z) then
blockY = true
end
elseif casing.velocityY < 0 and oldEdgeY > EDGE_TOL and edgeY <= EDGE_TOL then
local neighbor = getCell():getGridSquare(sx, sy - 1, sz)
if neighbor and SpentCasingPhysics.isBlockedBetweenSquares(casing.square, neighbor, SpentCasingPhysics.IsoDirections.N, casing.z) then
blockY = true
end
end

if blockX then
casing.velocityX = -casing.velocityX * SpentCasingPhysics.BOUNCE_RESTITUTION
casing.x = casing.x + (casing.velocityX * SpentCasingPhysics.BOUNCE_POSITION_CORRECT)
if math.abs(casing.velocityX) < SpentCasingPhysics.BOUNCE_MIN_VELOCITY then
casing.velocityX = 0
end
end

if blockY then
casing.velocityY = -casing.velocityY * SpentCasingPhysics.BOUNCE_RESTITUTION
casing.y = casing.y + (casing.velocityY * SpentCasingPhysics.BOUNCE_POSITION_CORRECT)
if math.abs(casing.velocityY) < SpentCasingPhysics.BOUNCE_MIN_VELOCITY then
casing.velocityY = 0
end
end

if blockX or blockY then
worldX = casing.square:getX() + casing.x
worldY = casing.square:getY() + casing.y
end

local targetTileX = math.floor(worldX)
local targetTileY = math.floor(worldY)

local MIN_Z = -1
local checkZ = worldZ
local targetSquare = nil
local drops = 0

while checkZ >= MIN_Z do
local sq = getCell():getGridSquare(targetTileX, targetTileY, checkZ)

if not sq then
break
end

if sq:getFloor() then
targetSquare = sq
break
end

checkZ = checkZ - 1
drops = drops + 1
end

if not targetSquare then
targetSquare = casing.square
else
if drops > 0 then
casing.z = casing.z + drops
end
end

local localX2 = worldX - targetSquare:getX()
local localY2 = worldY - targetSquare:getY()

localX2 = PZMath.clamp_01(localX2)
localY2 = PZMath.clamp_01(localY2)

if casing.currentWorldItem then
local wobj = casing.currentWorldItem:getWorldItem()
if wobj then
if isServer() then
casing.square:transmitRemoveItemFromSquare(wobj)
end
casing.square:removeWorldObject(wobj)
end
casing.currentWorldItem = nil
end

local falling = (casing.velocityZ <= 0)

local tileTopZ = nil
if not casing.hasHitFloor and falling then
tileTopZ = SpentCasingPhysics.getTileTopZ(targetSquare)
end

local surfaceZ = 0.0

if tileTopZ then
if prevZ >= tileTopZ and casing.z <= tileTopZ then
surfaceZ = tileTopZ
end
end

if casing.z > surfaceZ then
casing.currentWorldItem = targetSquare:AddWorldInventoryItem(
casing.casingType,
localX2,
localY2,
casing.z
)
else
local floor = targetSquare and targetSquare:getFloor() or nil

if surfaceZ == 0.0 then
casing.hasHitFloor = true
end

if surfaceZ == 0.0 and SpentCasingPhysics.isWaterFloor(floor) then
casing.active = false
table.remove(SpentCasingPhysics.activeCasings, i)
removed = true
SpentCasingPhysics.playCasingImpactSound(casing, targetSquare)
else
local speedXY = math.sqrt(
casing.velocityX * casing.velocityX +
casing.velocityY * casing.velocityY
)

local canBounceHere =
casing.floorBounces and casing.floorBounces > 0 and
speedXY > SpentCasingPhysics.SETTLE_THRESHOLD
if surfaceZ == 0.0 and floor and SpentCasingPhysics.isSoftFloor(floor) then
canBounceHere = false
end

if canBounceHere then
casing.floorBounces     = casing.floorBounces - 1
casing.z                = surfaceZ + 0.05
casing.velocityZ        = math.abs(casing.velocityZ) * SpentCasingPhysics.BOUNCE_RESTITUTION
casing.velocityX        = casing.velocityX * 0.5
casing.velocityY        = casing.velocityY * 0.5

casing.currentWorldItem = targetSquare:AddWorldInventoryItem(
casing.casingType,
localX2,
localY2,
casing.z
)
SpentCasingPhysics.playCasingImpactSound(casing, targetSquare)
else
targetSquare:AddWorldInventoryItem(
casing.casingType,
localX2,
localY2,
surfaceZ
)
SpentCasingPhysics.playCasingImpactSound(casing, targetSquare)
casing.active = false
table.remove(SpentCasingPhysics.activeCasings, i)
removed = true
end
end
end

if not removed then
if targetSquare ~= casing.square then
casing.square = targetSquare
end

casing.x = PZMath.clamp_01(localX2)
casing.y = PZMath.clamp_01(localY2)
end
end

if not removed then
i = i + 1
end
end
end
end
